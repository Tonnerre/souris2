<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="description" content="Jeu de plateforme avec cycle jour/nuit - Par Esteban Munoz Motsou" />
  <title>Jeu de la Souris - Esteban Munoz Motsou</title>
  <!-- build: 2025-10-12 16:55 cache-bust v1 -->
  <link rel="preload" as="image" href="assets/img/souris.png" />
  <link rel="preload" as="image" href="assets/img/chat.png" />
  <link rel="preload" as="image" href="assets/img/aviondg.png" />
  <link rel="preload" as="image" href="assets/img/aviongd.png" />
  <link rel="preload" as="image" href="assets/img/cloud.svg" />
  <link rel="preload" as="audio" href="assets/sounds/backgound.mp3" />
  <style>
    :root {
      --game-width: min(90vw, 1200px);
      /* Réduire la hauteur par défaut sur PC pour libérer de l'espace sous le jeu */
      --game-height: min(32vw, 420px);
      --ground-height: min(5vw, 60px);
    }
    /* Espace haut/bas dédié sur PC (pointeur fin) */
    @media (hover: hover) and (pointer: fine) {
      body { padding: 0 0 160px 0; }
      #game { margin-top: 48px; margin-bottom: 12px; }
    }
    @media (max-width: 768px) {
      :root { --game-width: 100vw; --game-height: 55vh; --ground-height: 6vh; }
      /* Plus d'espace blanc en bas pour les boutons tactiles (flèches + S) */
      body { padding: 24px 0 96px 0; justify-content: flex-start; overflow: hidden; }
      #game { margin: 24px 0 0 0; }
      #hud { font-size: 11px; top: 24px; left: 4px; padding: 3px 6px; display: flex; flex-direction: column; gap: 2px; }
      /* Ne pas forcer ici: gestion via media query coarse-pointer plus bas */
      #controls { display: initial !important; }
      #signature {
        font-size: 8px;
        top: 2px !important;
        left: 4px !important;
        right: auto !important;
        bottom: auto !important;
        padding: 2px 4px;
        background: rgba(0,0,0,0.35) !important;
        display: inline-block; width: auto; max-width: 60vw;
        text-align: left;
      }
      /* Smaller arrows in portrait */
      #touch-controls button { width: 44px; height: 44px; font-size: 20px; }
      /* Boutons tactiles en positions fixes pour éviter tout chevauchement */
      #touch-left { position: fixed; left: 16px; bottom: 18px; z-index: 56; }
      #touch-right { position: fixed; left: 72px; bottom: 18px; z-index: 56; }
      #touch-jump { position: fixed; right: 16px; bottom: 18px; z-index: 56; }
      /* Super saut portrait: visible et centré en bas */
      #touch-super-jump { display: block; position: fixed; bottom: 64px; left: 50%; transform: translateX(-50%); width: 56px; height: 56px; border-radius: 50%; background: rgba(60, 60, 150, 0.85); border: 4px solid rgba(255, 255, 255, 0.95); color: white; font-size: 22px; font-weight: bold; cursor: pointer; touch-action: none; user-select: none; box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7); }
      /* Super saut bouton en portrait */
      #touch-super-jump {
        transition: all 0.1s;
        z-index: 55;
      }
      #touch-super-jump:active { background: rgba(150, 150, 255, 0.9); transform: scale(0.9); box-shadow: 0 2px 4px rgba(0,0,0,0.5); border-color: #00ff00; }
      #touch-super-jump.pressed { background: rgba(120, 120, 255, 0.95) !important; border-color: #00ff88 !important; transform: scale(0.92); }
    }
    /* Landscape orientation on mobile/tablet: ensure barriers fully visible, controls hidden by default */
    @media (max-width: 1024px) and (orientation: landscape) {
      :root { --game-width: 100vw; --game-height: 60vh; --ground-height: 10vh; }
      /* Ne pas masquer ici: gestion via media query coarse-pointer plus bas */
      #controls { display: initial !important; }
      .barrier { height: 36px; }
      #hills-canvas { height: 140px; }
      /* Laisser moins de marge: flèches plus petites */
      /* Espace pour laisser respirer les contrôles en bas */
      body { padding-bottom: 108px; }
      #touch-controls button { width: 36px; height: 36px; font-size: 18px; }
      /* Positions fixes pour éviter chevauchements en paysage */
      #touch-left { position: fixed; left: 16px; bottom: 16px; z-index: 56; }
      #touch-right { position: fixed; left: 68px; bottom: 16px; z-index: 56; }
      #touch-jump { position: fixed; right: 16px; bottom: 16px; z-index: 56; }
      #touch-super-jump {
        display: block;
        position: fixed;
        bottom: 28px;
        left: 50%;
        transform: translateX(-50%);
        width: 52px;
        height: 52px;
        border-radius: 50%;
        background: rgba(60, 60, 150, 0.85);
        border: 4px solid rgba(255, 255, 255, 0.95);
        color: white;
        font-size: 22px;
        font-weight: bold;
        cursor: pointer;
        touch-action: none;
        user-select: none;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
        transition: all 0.1s;
      }
      #touch-super-jump:active {
        background: rgba(150, 150, 255, 0.9);
        transform: scale(0.9);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        border-color: #00ff00;
      }
      #touch-super-jump.pressed {
        background: rgba(120, 120, 255, 0.95) !important;
        border-color: #00ff88 !important;
        transform: scale(0.92);
      }
    }
    #mobile-actions {
      position: fixed;
      top: 8px;
      right: 8px;
      gap: 8px;
      display: none;
      z-index: 70;
      pointer-events: none;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      font-family: system-ui, sans-serif;
      height: 100%;
    }
    body {
      display: flex; flex-direction: column;
      align-items: center; justify-content: flex-start; padding: 0;
    }
    /* Dimensions explicites de la scène de jeu */
    #game {
      position: relative;
      width: var(--game-width);
      height: var(--game-height);
      margin: 40px auto 0; /* bande blanche en haut par défaut */
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    #startCenter {
      position: absolute; inset: 0; display: flex;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.2); z-index: 30;
    }
    #startCenter button {
      font-size: 18px; padding: 8px 16px; border-radius: 8px;
      background: #3a6ea5; color: #fff; cursor: pointer;
    }
    #hud {
      position: absolute; top: 4px; left: 6px; padding: 6px 8px;
      background: rgba(0,0,0,0.35); color: #fff; font-weight: 700;
      border-radius: 6px; z-index: 20; display: flex !important; flex-direction: column !important; gap: 2px;
    }
    #hud > div { line-height: 1.1; }
    #signature {
      position: fixed; top: 4px; right: 8px; bottom: auto !important;
      color: #fff;
      background: rgba(0,0,0,0.35) !important; /* petit fond uniquement sous le texte */
      padding: 4px 8px; border-radius: 6px; font-size: 12px;
      z-index: 60; text-align: right; pointer-events: none; white-space: nowrap;
      display: inline-block; width: auto; max-width: 60vw;
    }
    /* Masquer par défaut le bouton Super Saut (uniquement mobile) */
    #touch-super-jump { display: none; }
    .sidewalk {
      position: absolute; left: 0; right: 0; bottom: 0;
      height: var(--ground-height);
      background: linear-gradient(#b1b6be, #939aa4);
      border-top: 2px solid #707782;
    }
    #souris, .chat {
      position: absolute; bottom: var(--ground-height);
      background-repeat: no-repeat; background-position: center;
      background-size: contain;
    }
    #souris {
      left: min(60px, 10vw); background-image: url("assets/img/souris.png");
      width: min(48px, 6.5vw); height: min(48px, 6.5vw); z-index: 10;
    }
    .chat {
      background-image: url("assets/img/chat.png");
      width: min(72px, 9.75vw); height: min(72px, 9.75vw);
      background-size: 100% 100%; z-index: 5;
    }
    .sky-object {
      position: absolute; top: 8px;
      width: min(96px, 12vw); height: min(36px, 4.5vw);
      background-repeat: no-repeat; background-size: contain;
    }
    .barrier {
      position: absolute;
      bottom: var(--ground-height);
      width: 10px;
      height: 80px;
      background: linear-gradient(to right, #8b6f47 0%, #a0826b 50%, #8b6f47 100%);
      border-top: 3px solid #6b5638;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
      z-index: 2;
      opacity: 1;
    }
    .barrier::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      left: -4px;
      right: -4px;
      height: 12px;
      background: linear-gradient(to bottom, #a08060 0%, #8b7355 100%);
      border-radius: 4px 4px 0 0;
    }
    .barrier-rail {
      position: absolute;
      bottom: calc(var(--ground-height) + 80px);
      left: 0;
      right: 0;
      height: 8px;
      background: linear-gradient(to bottom, #a08060 0%, #8b7355 50%, #6d5a45 100%);
      border-top: 2px solid #5a4a38;
      border-bottom: 2px solid #5a4a38;
      pointer-events: none;
      z-index: 2;
      opacity: 1;
    }
    #hills-canvas {
      position: absolute;
      bottom: var(--ground-height);
      left: 0;
      width: 100%;
      height: 200px;
      pointer-events: none;
      z-index: 1;
    }
    #sun {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(circle, #ffeb3b 0%, #ffc107 50%, #ff9800 100%);
      box-shadow: 0 0 40px rgba(255, 235, 59, 0.8), 0 0 80px rgba(255, 235, 59, 0.4);
      pointer-events: none;
      z-index: 0;
      transition: all 1s ease;
    }
    #moon {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #f0f0f0 0%, #d0d0d0 50%, #a0a0a0 100%);
      box-shadow: 0 0 30px rgba(200, 200, 220, 0.6), 0 0 60px rgba(200, 200, 220, 0.3),
                  inset -10px -10px 20px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      z-index: 0;
      transition: all 1s ease;
      opacity: 0;
    }
    /* Mobile: sun/moon smaller */
    @media (max-width: 768px) {
      #sun { width: 56px; height: 56px; }
      #moon { width: 50px; height: 50px; }
    }
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.45);
      color: #fff; display: none; align-items: center;
      justify-content: center; text-align: center;
      z-index: 9999;
    }
    .overlay.show { display: flex; }
    .overlay .panel {
      background: rgba(0,0,0,0.55); padding: 16px 20px;
      border-radius: 8px;
      color: #fff;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    #controls {
      position: fixed; left: 50%; bottom: 8px; transform: translateX(-50%);
      width: var(--game-width); max-width: 1200px; margin: 0 auto;
      background: rgba(255,255,255,0.85); border: 1px solid #b8c6d8;
      border-radius: 8px; padding: 8px 12px; display: flex;
      flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center;
      z-index: 90;
    }
    #touch-controls {
      display: none; /* will be placed inside #touch-bar on mobile */
      position: static;
      justify-content: flex-start;
      padding: 0;
      pointer-events: auto;
      margin: 0;
    }
    #touch-controls button {
      pointer-events: auto;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.95);
      background: rgba(40, 40, 40, 0.85);
      color: white;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      touch-action: none;
      user-select: none;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
      transition: all 0.1s;
    }
    #touch-controls button:active {
      background: rgba(150, 150, 255, 0.9);
      transform: scale(0.9);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      border-color: #00ff00;
    }
    #touch-controls button.pressed {
      background: rgba(120, 120, 255, 0.95) !important;
      border-color: #00ff88 !important;
      transform: scale(0.92);
    }
    #touch-jump {
      background: rgba(60, 60, 150, 0.85) !important;
    }
    #touch-jump:active {
      background: rgba(100, 100, 255, 0.95) !important;
    }
    /* Fixed bottom bar container for mobile controls */
    #touch-bar { display: none; }
    @media (hover: none) and (pointer: coarse) {
      #touch-bar {
        position: fixed; left: 50%; bottom: 0; transform: translateX(-50%);
        width: var(--game-width); max-width: 100vw;
        height: 72px; /* portrait reduced */
        display: flex; align-items: center; justify-content: space-between;
        padding: 8px 12px; box-sizing: border-box;
        background: rgba(255,255,255,0.0); /* transparent organizational bar */
        z-index: 80; pointer-events: none;
      }
      /* landscape slightly taller */
      @media (orientation: landscape) {
        #touch-bar { height: 80px; }
      }
      /* Left group: arrows */
      #touch-controls { pointer-events: auto; display: flex; gap: 14px; }
      /* Right group: we will append #touch-super-jump and #touch-jump into #touch-right-group */
      #touch-right-group { display: flex; align-items: center; gap: 14px; pointer-events: auto; }
    }
    /* Boutons Pause/Restart mobiles */
    #mobile-actions { display: none; position: fixed; top: 8px; right: 8px; z-index: 50; gap: 6px; }
    #mobile-actions button { pointer-events: auto; padding: 6px 10px; font-size: 14px; border-radius: 6px; border: 2px solid rgba(255,255,255,0.9); color: #fff; background: rgba(0,0,0,0.5); box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
    #mobile-actions button:active { transform: scale(0.95); }
    /* Show mobile UI only on touch/coarse-pointer devices */
    @media (hover: none) and (pointer: coarse) {
      #mobile-actions { display: flex; }
      #touch-controls { display: flex; }
      /* Masquer les réglages PC sur mobile */
      #controls { display: none !important; }
      /* Toujours afficher le bouton super saut sur mobile */
      #touch-super-jump { display: block; }
      /* Annuler tout positionnement fixé pour utiliser la barre #touch-bar */
      #touch-left, #touch-right, #touch-jump {
        position: static !important; left: auto !important; right: auto !important; bottom: auto !important;
      }
    }
    /* Make mobile settings dialog overlay everything */
    #mobile-settings { z-index: 80 !important; }
    #controls label {
      display: inline-flex; align-items: center; gap: 6px;
      font-weight: 600; white-space: nowrap; font-size: 14px;
    }
    #controls input[type="range"] {
      vertical-align: middle; min-width: 80px; max-width: 150px;
    }
    #controls button {
      padding: 4px 8px; white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="startCenter"><button id="startPlayBtn">Jouer</button></div>
    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Niveau: <span id="level">1</span></div>
      <div>Super: <span id="superStatus">—</span></div>
    </div>
    <div id="sun"></div>
    <div id="moon"></div>
    <canvas id="hills-canvas"></canvas>
    <div class="barrier-rail"></div>
    <div class="sidewalk"></div>
    <div id="souris"></div>
    <div id="touch-controls">
      <button id="touch-left" type="button">←</button>
      <button id="touch-jump" type="button">↑</button>
      <button id="touch-right" type="button">→</button>
    </div>
    <button id="touch-super-jump" type="button" aria-label="Super Saut">S</button>
    <div id="mobile-actions">
      <button id="mobile-pause" type="button">⏸️</button>
      <button id="mobile-restart" type="button">⟳</button>
    </div>
    <button id="mobile-settings-btn" style="display: none; position: absolute; top: 40px; right: 8px; z-index: 30; background: rgba(0,0,0,0.5); color: white; border: 2px solid white; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer;">⚙️</button>
    <div id="mobile-settings" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 40; padding: 20px; overflow-y: auto;">
      <button id="close-settings" style="position: absolute; top: 10px; right: 10px; background: #f44336; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 24px; cursor: pointer;">×</button>
      <h2 style="color: white; text-align: center; margin-top: 40px;">Réglages</h2>
      <div id="mobile-controls-container" style="color: white; padding: 20px;">
      </div>
    </div>
    <div id="overlay" class="overlay">
      <div class="panel">
        <h2>Game Over</h2>
        <button id="overlayRestartBtn" type="button" style="margin-top: 10px; padding: 8px 14px; font-size: 16px; border: 2px solid #fff; border-radius: 8px; background: rgba(0,0,0,0.35); color: #fff; cursor: pointer;">Rejouer</button>
      </div>
    </div>
  </div>
  <!-- Barre de contrôles mobile en bas (hors zone de jeu) -->
  <div id="touch-bar"></div>
  <div id="signature">© 2025 - Esteban Munoz Motsou (8 ans)</div>
  <audio id="backgroundMusic" loop>
    <source src="assets/sounds/backgound.mp3" type="audio/mpeg">
  </audio>
  <div id="controls">
    <label for="jumpScale">
      Portée du saut
      <button id="jumpScaleMinus" type="button">−</button>
      <input id="jumpScale" type="range" min="0.6" max="1.8" step="0.05" value="1.0" />
      <button id="jumpScalePlus" type="button">+</button>
      <span id="jumpValue">1.00×</span>
    </label>
    <label for="jumpHeight">
      Hauteur du saut
      <button id="jumpHeightMinus" type="button">−</button>
      <input id="jumpHeight" type="range" min="0.6" max="4.0" step="0.05" value="2.55" />
      <button id="jumpHeightPlus" type="button">+</button>
      <span id="jumpHeightValue">2.55×</span>
    </label>
    <button id="superJumpBtn" type="button">Super Saut (S)</button>
    <button id="playBtn">Jouer</button>
    <button id="pauseBtn">Pause</button>
  </div>
  <script>
(function() {
  const game = document.getElementById('game');
  const souris = document.getElementById('souris');
  const overlay = document.getElementById('overlay');
  const backgroundMusic = document.getElementById('backgroundMusic');
  const scoreEl = document.getElementById('score');
  
  const WIDTH = parseInt(getComputedStyle(game).width) || 600;
  const HEIGHT = parseInt(getComputedStyle(game).height) || 240;
  function getGameWidth() { return game.clientWidth || WIDTH; }
  function getGameHeight() { return game.clientHeight || HEIGHT; }
  function isMobileEnv() {
    return (window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches) || window.innerWidth <= 1024;
  }
  
  function applyResponsiveLayout() {
    const isMobile = isMobileEnv();
    const portrait = window.innerHeight >= window.innerWidth;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    if (!isMobile) {
      // PC: conserver la taille CSS par défaut (pas de forçage inline)
      game.style.width = '';
      game.style.height = '';
      // Ne pas écraser les variables CSS globales
      return;
    }
    // MOBILE: réduire la hauteur pour éviter tout chevauchement
    const gameH = Math.round(vh * (portrait ? 0.52 : 0.50));
    const groundH = Math.round(vh * (portrait ? 0.06 : 0.10));
    game.style.width = vw + 'px';
    game.style.height = gameH + 'px';
    document.documentElement.style.setProperty('--game-width', vw + 'px');
    document.documentElement.style.setProperty('--game-height', gameH + 'px');
    document.documentElement.style.setProperty('--ground-height', groundH + 'px');
    // Ensure hills canvas adapts
    hillsCanvas.width = vw;
    // Keep a stable hills canvas height appropriate for both orientations
    hillsCanvas.height = Math.max(140, Math.min(220, Math.round(gameH * 0.6)));
    // Ensure mobile actions visibility in both orientations (unless settings open)
    const mobileActions = document.getElementById('mobile-actions');
    const touchControls = document.getElementById('touch-controls');
    const signatureEl = document.getElementById('signature');
    const settingsOpen = document.getElementById('mobile-settings')?.style.display === 'block';
    if (!settingsOpen) {
      const showMobile = isMobileEnv();
      if (mobileActions) mobileActions.style.display = showMobile ? 'flex' : 'none';
      if (touchControls) touchControls.style.display = showMobile ? 'flex' : 'none';
    }

    // Signature handling: on mobile portrait, abbreviate and ensure it cannot create a translucent block
    if (signatureEl) {
      const onMobilePortrait = isMobileEnv() && portrait;
      if (onMobilePortrait) {
        signatureEl.textContent = 'E. Munoz-Motsou';
        signatureEl.style.background = 'none';
        signatureEl.style.boxShadow = 'none';
        signatureEl.style.backdropFilter = 'none';
        signatureEl.style.display = 'inline-block';
        signatureEl.style.pointerEvents = 'none';
        signatureEl.style.width = 'auto';
        signatureEl.style.maxWidth = '60vw';
        signatureEl.style.top = '4px';
        signatureEl.style.left = '4px';
        signatureEl.style.right = 'auto';
        signatureEl.style.textAlign = 'left';
      } else {
        signatureEl.textContent = '© 2025 - Esteban Munoz Motsou (8 ans)';
        signatureEl.style.background = 'none';
        signatureEl.style.top = '4px';
        signatureEl.style.right = '8px';
        signatureEl.style.left = 'auto';
        signatureEl.style.textAlign = 'right';
      }
    }
  }
  const GROUND_HEIGHT = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ground-height')) || 40;
  
  const GRAVITY = 1800;
  const MOVE_ACCEL = 2200;
  const MAX_SPEED_X = 240;
  const JUMP_VELOCITY = 560;
  const JUMP_RANGE_IMPULSE = 180;
  const FRICTION = 2000;
  const CAT_MIN_SPEED = 80;
  const CAT_MAX_SPEED = 160;
  const SCORE_RATE = 10;
  const SKY_MIN_DELAY = 3;
  const SKY_MEAN_EXTRA = 4;
  
  let jumpRangeScale = 1.0;
  let jumpHeightScale = 2.55;
  const JUMP_SCALE_STEP = 0.05;
  
  let running = false;
  let gameOver = false;
  
  const input = { left: false, right: false, jump: false };
  
  const mouseSize = Math.min(48, getGameWidth() * 0.08);
  const catSize = mouseSize * 1.5;
  
  souris.style.width = mouseSize + 'px';
  souris.style.height = mouseSize + 'px';
  
  // Centrer la souris sur la route (au milieu de la zone ground)
  const roadCenterOffset = GROUND_HEIGHT / 2 - mouseSize / 2;
  
  const player = {
    x: Math.min(60, getGameWidth() * 0.1), y: roadCenterOffset, vx: 0, vy: 0,
    width: mouseSize, height: mouseSize, onGround: true
  };
  
  const cats = [];
  const barriers = [];
  let score = 0;
  let scoreAccum = 0;
  let nextCatTime = 0;
  let nextBarrierTime = 0;
  let level = 1;
  let nextLevelAt = 125;
  let nextJumpSuper = false;
  let dayNightProgress = 0; // Progression continue de 0 (jour) à 1 (nuit)
  
  // Canvas pour les collines
  const hillsCanvas = document.getElementById('hills-canvas');
  const hillsCtx = hillsCanvas.getContext('2d');
  hillsCanvas.width = getGameWidth();
  hillsCanvas.height = 200;
  // Apply responsive sizing immediately
  applyResponsiveLayout();
  
  const sun = document.getElementById('sun');
  const moon = document.getElementById('moon');
  
  // Fonction d'interpolation linéaire entre deux couleurs
  function lerpColor(color1, color2, t) {
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);
    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);
    
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }
  
  // Fonction pour mettre à jour le cycle jour/nuit progressivement
  function updateDayNight() {
    // Progression de 0 (jour) à 1 (nuit) sur 300 points
    const progress = Math.min(dayNightProgress, 1);
    
    // Couleurs du ciel
    let skyTop, skyMid, skyBottom;
    let hillTop, hillMid, hillBottom;
    let riverR, riverG, riverB, riverA;
    
    if (progress < 0.33) { // Jour -> Fin d'après-midi
      const t = progress / 0.33;
      skyTop = lerpColor('#b9dcff', '#8fb4d9', t);
      skyMid = lerpColor('#d6ecff', '#a8c5e0', t);
      skyBottom = lerpColor('#ffffff', '#d0d8e0', t);
      hillTop = lerpColor('#7cb342', '#6fa83a', t);
      hillMid = lerpColor('#689f38', '#5a8f30', t);
      hillBottom = lerpColor('#558b2f', '#4a7528', t);
      riverR = 100 - 10 * t;
      riverG = 150 - 20 * t;
      riverB = 200 - 20 * t;
      riverA = 0.6;
    } else if (progress < 0.67) { // Fin d'après-midi -> Crépuscule
      const t = (progress - 0.33) / 0.34;
      skyTop = lerpColor('#8fb4d9', '#ff9a56', t);
      skyMid = lerpColor('#a8c5e0', '#ff6b9d', t);
      skyBottom = lerpColor('#d0d8e0', '#c94b4b', t);
      hillTop = lerpColor('#6fa83a', '#5a8f2f', t);
      hillMid = lerpColor('#5a8f30', '#4a7528', t);
      hillBottom = lerpColor('#4a7528', '#3a5a20', t);
      riverR = 90 + 60 * t;
      riverG = 130 - 30 * t;
      riverB = 180 - 30 * t;
      riverA = 0.6 - 0.1 * t;
    } else { // Crépuscule -> Nuit
      const t = (progress - 0.67) / 0.33;
      skyTop = lerpColor('#ff9a56', '#0a1128', t);
      skyMid = lerpColor('#ff6b9d', '#1a2332', t);
      skyBottom = lerpColor('#c94b4b', '#2a3a4a', t);
      hillTop = lerpColor('#5a8f2f', '#2d4a2d', t);
      hillMid = lerpColor('#4a7528', '#1f3a1f', t);
      hillBottom = lerpColor('#3a5a20', '#152815', t);
      riverR = 150 - 70 * t;
      riverG = 100;
      riverB = 150 - 10 * t;
      riverA = 0.5;
    }
    
    game.style.background = `linear-gradient(${skyTop} 0%, ${skyMid} 50%, ${skyBottom} 100%)`;
    
    // Mettre à jour la position et l'apparence du soleil
    updateSunPosition(progress);
  }
  
  function updateSunPosition(progress) {
    if (!sun) return;
    
    // Position du soleil selon le cycle
    let sunX, sunY, sunOpacity, sunColor, sunGlow;
    
    if (progress < 0.15) { // Lever de soleil
      const t = progress / 0.15;
      sunX = getGameWidth() * 0.85;
      sunY = getGameHeight() * 0.6 - (getGameHeight() * 0.4) * t; // Monte depuis l'horizon
      sunOpacity = t; // Apparaît progressivement
      // Couleurs chaudes du lever
      const redness = Math.floor(255 - 20 * t);
      sunColor = `radial-gradient(circle, #ff${redness.toString(16)}3b 0%, #ff${Math.floor(193 + 42 * t).toString(16)}07 50%, #ff${Math.floor(152 + 103 * t).toString(16)}00 100%)`;
      sunGlow = `0 0 ${60 - 20 * t}px rgba(255, ${150 + 105 * t}, 50, ${0.6 + 0.2 * t}), 0 0 ${100 - 20 * t}px rgba(255, ${100 + 155 * t}, 50, ${0.3 + 0.1 * t})`;
    } else if (progress < 0.5) { // Jour - soleil haut dans le ciel
      const t = (progress - 0.15) / 0.35;
      sunX = getGameWidth() * 0.85;
      sunY = getGameHeight() * 0.2 - 10 * t; // Légèrement plus haut
      sunOpacity = 1;
      sunColor = 'radial-gradient(circle, #ffeb3b 0%, #ffc107 50%, #ff9800 100%)';
      sunGlow = '0 0 40px rgba(255, 235, 59, 0.8), 0 0 80px rgba(255, 235, 59, 0.4)';
    } else if (progress < 0.65) { // Coucher de soleil
      const t = (progress - 0.5) / 0.15;
      sunX = getGameWidth() * 0.85;
      sunY = getGameHeight() * 0.2 + (getGameHeight() * 0.4) * t; // Descend vers l'horizon
      sunOpacity = 1 - 0.5 * t;
      // Soleil devient orange/rouge au coucher
      const redness = Math.floor(235 - 100 * t);
      sunColor = `radial-gradient(circle, #ff${redness.toString(16)}3b 0%, #ff${Math.floor(193 - 100 * t).toString(16)}07 50%, #ff${Math.floor(152 - 80 * t).toString(16)}00 100%)`;
      sunGlow = `0 0 ${40 + 60 * t}px rgba(255, ${100 - 50 * t}, 50, ${0.8 - 0.3 * t}), 0 0 ${80 + 60 * t}px rgba(255, ${100 - 50 * t}, 50, ${0.4 - 0.2 * t})`;
    } else { // Nuit - soleil complètement couché
      sunX = getGameWidth() * 0.85;
      sunY = getGameHeight() * 0.7;
      sunOpacity = 0;
      sunColor = 'radial-gradient(circle, #ff6b3b 0%, #ff3b07 50%, #ff2800 100%)';
      sunGlow = '0 0 20px rgba(255, 50, 30, 0.3)';
    }
    
    sun.style.left = sunX + 'px';
    sun.style.top = sunY + 'px';
    sun.style.opacity = sunOpacity;
    sun.style.background = sunColor;
    sun.style.boxShadow = sunGlow;
    
    // Mettre à jour la lune
    updateMoonPosition(progress);
  }
  
  function updateMoonPosition(progress) {
    if (!moon) return;
    
    let moonX, moonY, moonOpacity;
    
    if (progress < 0.65) { // Jour et crépuscule - lune cachée sous l'horizon
      moonX = getGameWidth() * 0.15;
      moonY = getGameHeight() * 0.7; // Sous l'horizon
      moonOpacity = 0;
    } else if (progress < 0.8) { // Lever de lune
      const t = (progress - 0.65) / 0.15;
      moonX = getGameWidth() * 0.15;
      moonY = getGameHeight() * 0.7 - (getGameHeight() * 0.5) * t; // Monte depuis l'horizon
      moonOpacity = t; // Apparaît progressivement
    } else if (progress < 0.95) { // Nuit - lune haute
      const t = (progress - 0.8) / 0.15;
      moonX = getGameWidth() * 0.15;
      moonY = getGameHeight() * 0.2 - 10 * t; // Légèrement plus haute
      moonOpacity = 1;
    } else { // Coucher de lune (fin de cycle)
      const t = (progress - 0.95) / 0.05;
      moonX = getGameWidth() * 0.15;
      moonY = getGameHeight() * 0.2 + (getGameHeight() * 0.5) * t; // Descend vers l'horizon
      moonOpacity = 1 - t; // Disparaît progressivement
    }
    
    moon.style.left = moonX + 'px';
    moon.style.top = moonY + 'px';
    moon.style.opacity = moonOpacity;
  }
  
  // Génération de la sinusoïde irrégulière pour les collines
  let hillsOffset = 0;
  const hillsSpeed = 15; // Vitesse de défilement des collines (réduite)
  
  function generateHillPoints(offset, canvasWidth, isMobile) {
    // Screen-space sampling: x in [0..canvasWidth], y from phase (x + offset)
    const points = [];
    const ampFactor = isMobile ? 0.6 : 1.0;
    const baseHeight = isMobile ? 70 : 90;
    const segments = Math.max(80, Math.ceil(canvasWidth / 10));
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = t * canvasWidth;
      const phase = x + offset;
      const y1 = Math.sin(phase * 0.003) * 40 * ampFactor;
      const y2 = Math.sin(phase * 0.007) * 30 * ampFactor;
      const y3 = Math.sin(phase * 0.015) * 20 * ampFactor;
      const y = baseHeight + y1 + y2 + y3;
      points.push({ x, y });
    }
    return points;
  }
  
  function drawHills() {
    // Ensure the hills canvas matches the current game width (responsive)
    const desiredWidth = game.clientWidth || WIDTH;
    if (hillsCanvas.width !== desiredWidth) {
      hillsCanvas.width = desiredWidth;
    }
    hillsCtx.clearRect(0, 0, hillsCanvas.width, hillsCanvas.height);
    
    const cw = hillsCanvas.width;
    const ch = hillsCanvas.height;
    const isMobile = window.innerWidth <= 768;
    const points = generateHillPoints(hillsOffset, cw, isMobile);
    
    // Dessiner le paysage de collines (plein écran)
    hillsCtx.beginPath();
    hillsCtx.moveTo(0, ch);
    hillsCtx.lineTo(0, points[0].y);
    
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      if (i === 0) {
        hillsCtx.lineTo(p.x, p.y);
      } else {
        const prev = points[i - 1];
        const cp1x = prev.x + (p.x - prev.x) / 3;
        const cp1y = prev.y;
        const cp2x = prev.x + 2 * (p.x - prev.x) / 3;
        const cp2y = p.y;
        hillsCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
      }
    }
    
    hillsCtx.lineTo(cw, ch);
    hillsCtx.closePath();
    
    // Remplissage avec dégradé vert (herbe) - couleurs adaptées au cycle jour/nuit
    const progress = Math.min(dayNightProgress, 1);
    let hillTop, hillMid, hillBottom;
    let riverR, riverG, riverB, riverA;
    
    if (progress < 0.33) {
      const t = progress / 0.33;
      hillTop = lerpColor('#7cb342', '#6fa83a', t);
      hillMid = lerpColor('#689f38', '#5a8f30', t);
      hillBottom = lerpColor('#558b2f', '#4a7528', t);
      riverR = 100 - 10 * t;
      riverG = 150 - 20 * t;
      riverB = 200 - 20 * t;
      riverA = 0.6;
    } else if (progress < 0.67) {
      const t = (progress - 0.33) / 0.34;
      hillTop = lerpColor('#6fa83a', '#5a8f2f', t);
      hillMid = lerpColor('#5a8f30', '#4a7528', t);
      hillBottom = lerpColor('#4a7528', '#3a5a20', t);
      riverR = 90 + 60 * t;
      riverG = 130 - 30 * t;
      riverB = 180 - 30 * t;
      riverA = 0.6 - 0.1 * t;
    } else {
      const t = (progress - 0.67) / 0.33;
      hillTop = lerpColor('#5a8f2f', '#2d4a2d', t);
      hillMid = lerpColor('#4a7528', '#1f3a1f', t);
      hillBottom = lerpColor('#3a5a20', '#152815', t);
      // Garder la rivière clairement bleue la nuit
      riverR = 40 + 10 * t; // Très peu de rouge (reste bleu)
      riverG = 80 + 15 * t; // Bleu-vert foncé
      riverB = 150 + 10 * t; // Beaucoup de bleu (dominante bleue)
      riverA = 0.65; // Bien visible
    }
    
    let riverColor = `rgba(${Math.round(riverR)}, ${Math.round(riverG)}, ${Math.round(riverB)}, ${riverA})`;
    
    const gradient = hillsCtx.createLinearGradient(0, 80, 0, 200);
    gradient.addColorStop(0, hillTop);
    gradient.addColorStop(0.5, hillMid);
    gradient.addColorStop(1, hillBottom);
    hillsCtx.fillStyle = gradient;
    hillsCtx.fill();
    
    // Ajouter une rivière avec effet d'eau
    hillsCtx.beginPath();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const riverY = p.y + 20 + Math.sin((p.x + hillsOffset) * 0.01) * 5;
      if (i === 0) hillsCtx.moveTo(p.x, riverY);
      else hillsCtx.lineTo(p.x, riverY);
    }
    
    // Toujours garder l'apparence d'eau (bleu/reflets)
    hillsCtx.strokeStyle = riverColor;
    hillsCtx.lineWidth = 10;
    hillsCtx.lineCap = 'round';
    hillsCtx.stroke();
    
    // Ajouter des reflets lumineux pour effet d'eau
    hillsCtx.beginPath();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const riverY = p.y + 20 + Math.sin((p.x + hillsOffset) * 0.01) * 5;
      const shimmer = Math.sin((p.x + hillsOffset * 2) * 0.02) * 2;
      if (i === 0) hillsCtx.moveTo(p.x, riverY + shimmer);
      else hillsCtx.lineTo(p.x, riverY + shimmer);
    }
    
    // Reflets blancs/argentés selon l'heure
    let shimmerOpacity = progress < 0.67 ? 0.3 : 0.2; // Moins visible la nuit
    hillsCtx.strokeStyle = `rgba(255, 255, 255, ${shimmerOpacity})`;
    hillsCtx.lineWidth = 3;
    hillsCtx.stroke();
  }
  
  function scheduleNextCat() {
    const u = Math.random();
    nextCatTime = Math.max(1.0, -Math.log(1 - u) * 4.5);
  }
  
  function scheduleNextBarrier() {
    nextBarrierTime = 0.15; // Intervalle fixe pour barrières régulières
  }
  
  function spawnBarrier() {
    const el = document.createElement('div');
    el.className = 'barrier';
    el.style.left = getGameWidth() + 'px';
    game.appendChild(el);
    
    const speed = 180; // Vitesse fixe pour un défilement régulier
    barriers.push({ el, x: getGameWidth(), vx: -speed, width: 10 });
  }
  
  function spawnCat() {
    const el = document.createElement('div');
    el.className = 'chat';
    el.style.left = getGameWidth() + 'px';
    const roadCenterOffset = GROUND_HEIGHT / 2 - catSize / 2;
    el.style.bottom = (GROUND_HEIGHT + roadCenterOffset) + 'px';
    el.style.width = catSize + 'px';
    el.style.height = catSize + 'px';
    game.appendChild(el);
    
    const speed = CAT_MIN_SPEED + Math.random() * (CAT_MAX_SPEED - CAT_MIN_SPEED);
    cats.push({ el, x: getGameWidth(), y: roadCenterOffset, vx: -speed, width: catSize, height: catSize });
  }
  
  function onKeyDown(e) {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') { input.left = true; e.preventDefault(); }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') { input.right = true; e.preventDefault(); }
    if (e.code === 'Space' || e.code === 'ArrowUp') { input.jump = true; e.preventDefault(); }
    
    // Touche S pour super saut
    if (e.code === 'KeyS') {
      nextJumpSuper = true;
      const superStatus = document.getElementById('superStatus');
      if (superStatus) superStatus.textContent = 'armé';
    }
    
    // Touche P pour pause
    if (e.code === 'KeyP' && !gameOver) {
      e.preventDefault();
      running = !running;
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn) pauseBtn.textContent = running ? 'Pause' : 'Reprendre';
      if (backgroundMusic) {
        if (running) backgroundMusic.play().catch(() => {});
        else backgroundMusic.pause();
      }
      if (running) requestAnimationFrame(loop);
    }
    
    if (gameOver && e.code === 'KeyR') restart();
  }
  
  function onKeyUp(e) {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
    if (e.code === 'Space' || e.code === 'ArrowUp') input.jump = false;
  }
  
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);
  
  let lastTime = performance.now();
  scheduleNextCat();
  scheduleNextBarrier();
  
  // Initialiser les barrières au démarrage (quelques poteaux en plus pour couvrir le bord droit)
  for (let i = 0; i < Math.ceil(getGameWidth() / 27) + 5; i++) {
    const el = document.createElement('div');
    el.className = 'barrier';
    el.style.left = (i * 27) + 'px';
    game.appendChild(el);
    barriers.push({ el, x: i * 27, vx: -180, width: 10 });
  }
  
  // Dessiner les collines au démarrage
  drawHills();
  updateSunPosition(0); // Initialiser le soleil et la lune

  // Adapter au redimensionnement: redessiner les collines et reconstruire les barrières
  window.addEventListener('resize', () => {
    applyResponsiveLayout();
    drawHills();
    arrangeMobileBar();
    // Rebuild barriers to fill full width after orientation change
    for (const b of barriers) b.el.remove();
    barriers.length = 0;
    for (let i = 0; i < Math.ceil(getGameWidth() / 27) + 5; i++) {
      const el = document.createElement('div');
      el.className = 'barrier';
      el.style.left = (i * 27) + 'px';
      game.appendChild(el);
      barriers.push({ el, x: i * 27, vx: -180, width: 10 });
    }
    // Clamp player to new bounds
    player.x = Math.max(0, Math.min(getGameWidth() - player.width, player.x));
  });
  
  // Gérer la rotation: reconstruire après stabilisation du layout
  window.addEventListener('orientationchange', () => {
    setTimeout(() => {
      applyResponsiveLayout();
      const evt = new Event('resize');
      window.dispatchEvent(evt);
      arrangeMobileBar();
    }, 250);
  });
  
  function update(dt) {
    if (!running) return;
    
    // Mettre à jour et dessiner les collines
    hillsOffset += hillsSpeed * dt;
    drawHills();
    
    if (input.left) player.vx -= MOVE_ACCEL * dt;
    else if (input.right) player.vx += MOVE_ACCEL * dt;
    else if (player.onGround) {
      if (player.vx > 0) player.vx = Math.max(0, player.vx - FRICTION * dt);
      else if (player.vx < 0) player.vx = Math.min(0, player.vx + FRICTION * dt);
    }
    player.vx = Math.max(-MAX_SPEED_X, Math.min(MAX_SPEED_X, player.vx));
    
    if (input.jump && player.onGround) {
      const heightBoost = nextJumpSuper ? 1.8 : 1.0;
      // On mobile, slightly reduce jump height/speed for better control
      const mobileJumpFactor = isMobileEnv() ? 0.85 : 1.0;
      player.vy = JUMP_VELOCITY * jumpHeightScale * heightBoost * mobileJumpFactor;
      
      let dir = 0;
      if (input.right && !input.left) dir = 1;
      else if (input.left && !input.right) dir = -1;
      else if (player.vx !== 0) dir = Math.sign(player.vx);
      if (dir !== 0) {
        const rangeBoost = nextJumpSuper ? 1.5 : 1.0;
        player.vx += dir * JUMP_RANGE_IMPULSE * jumpRangeScale * rangeBoost;
      }
      
      nextJumpSuper = false; // Consommer le super saut
      player.onGround = false;
    }
    
    if (!player.onGround) player.vy -= GRAVITY * dt;
    
    player.x += player.vx * dt;
    player.x = Math.max(0, Math.min(getGameWidth() - player.width, player.x));
    
    player.y += player.vy * dt;
    const roadCenterOffset = GROUND_HEIGHT / 2 - mouseSize / 2;
    if (player.y <= roadCenterOffset) {
      player.y = roadCenterOffset;
      player.vy = 0;
      player.onGround = true;
    }
    
    souris.style.left = Math.round(player.x) + 'px';
    souris.style.bottom = (GROUND_HEIGHT + Math.round(player.y)) + 'px';
    
    scoreAccum += dt * SCORE_RATE;
    const inc = Math.floor(scoreAccum);
    if (inc > 0) {
      score += inc;
      scoreAccum -= inc;
      if (scoreEl) scoreEl.textContent = String(score);
      
      // Gestion des niveaux
      while (score >= nextLevelAt) {
        level += 1;
        const levelEl = document.getElementById('level');
        if (levelEl) levelEl.textContent = String(level);
        nextLevelAt += 125;
      }
      
      // Cycle jour/nuit progressif et continu (300 points pour la nuit, puis 165 pour revenir au jour)
      // Cycle complet = 465 points
      const cyclePosition = score % 465;
      let newProgress;
      
      if (cyclePosition <= 300) {
        // Phase 1: Jour -> Nuit (0-300 points)
        newProgress = cyclePosition / 300;
      } else {
        // Phase 2: Nuit -> Jour (300-465 points, soit 165 points)
        const nightToDayProgress = (cyclePosition - 300) / 165;
        newProgress = 1 - nightToDayProgress; // Revenir de 1 (nuit) à 0 (jour)
      }
      
      if (Math.abs(newProgress - dayNightProgress) > 0.01) {
        dayNightProgress = newProgress;
        updateDayNight();
      }
    }
    
    // Afficher l'état du super saut
    const superStatus = document.getElementById('superStatus');
    if (superStatus) superStatus.textContent = nextJumpSuper ? 'armé' : '—';
    
    for (let i = cats.length - 1; i >= 0; i--) {
      const c = cats[i];
      c.x += c.vx * dt;
      if (c.x < -c.width - 20) {
        c.el.remove();
        cats.splice(i, 1);
        continue;
      }
      c.el.style.left = Math.round(c.x) + 'px';
    }
    
    nextCatTime -= dt;
    if (nextCatTime <= 0) {
      spawnCat();
      scheduleNextCat();
    }
    
    // Barrières: déplacement + suppression hors écran
    for (let i = barriers.length - 1; i >= 0; i--) {
      const b = barriers[i];
      b.x += b.vx * dt;
      if (b.x < -b.width - 20) {
        b.el.remove();
        barriers.splice(i, 1);
        continue;
      }
      b.el.style.left = Math.round(b.x) + 'px';
    }
    
    nextBarrierTime -= dt;
    if (nextBarrierTime <= 0) {
      spawnBarrier();
      scheduleNextBarrier();
    }
    
    const a = {
      x: player.x, y: getGameHeight() - (GROUND_HEIGHT + player.y + player.height),
      w: player.width, h: player.height
    };
    for (const c of cats) {
      const b = {
        x: c.x, y: getGameHeight() - (GROUND_HEIGHT + c.y + c.height),
        w: c.width, h: c.height
      };
      if (!(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h)) {
        // Collision: game over
        onGameOver();
        return;
      }
    }
  }
  
  function loop(t) {
    const dt = Math.min(0.033, (t - lastTime) / 1000);
    lastTime = t;
    if (!gameOver) {
      update(dt);
      requestAnimationFrame(loop);
    }
  }
  
  function endGame() {
    gameOver = true;
    running = false;
    overlay.classList.add('show');
    if (backgroundMusic) backgroundMusic.pause();
    // Hide touch controls and mobile actions to avoid overlap while Game Over is shown
    const tc = document.getElementById('touch-controls');
    const ma = document.getElementById('mobile-actions');
    if (tc) tc.style.display = 'none';
    if (ma) ma.style.display = 'none';
  }
  
  // Wrapper attendu par la logique de collision
  function onGameOver() {
    endGame();
  }
  
  function restart() {
    for (const c of cats) c.el.remove();
    cats.length = 0;
    for (const b of barriers) b.el.remove();
    barriers.length = 0;
    
    const roadCenterOffset = GROUND_HEIGHT / 2 - mouseSize / 2;
    player.x = Math.min(60, getGameWidth() * 0.1);
    player.y = roadCenterOffset;
    player.vx = 0;
    player.vy = 0;
    player.onGround = true;
    hillsOffset = 0;
    
    score = 0;
    scoreAccum = 0;
    level = 1;
    nextLevelAt = 125;
    nextJumpSuper = false;
    dayNightProgress = 0;
    updateDayNight();
    if (scoreEl) scoreEl.textContent = '0';
    const levelEl = document.getElementById('level');
    if (levelEl) levelEl.textContent = '1';
    const superStatus = document.getElementById('superStatus');
    if (superStatus) superStatus.textContent = '—';
    
    gameOver = false;
    running = true;
    overlay.classList.remove('show');
    
    if (backgroundMusic) {
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(err => console.log('Autoplay bloqué'));
    }
    
    scheduleNextCat();
    scheduleNextBarrier();
    
    // Réinitialiser les barrières
  for (let i = 0; i < Math.ceil(getGameWidth() / 27) + 5; i++) {
    const el = document.createElement('div');
    el.className = 'barrier';
    el.style.left = (i * 27) + 'px';
    game.appendChild(el);
    barriers.push({ el, x: i * 27, vx: -180, width: 10 });
  }
    
    lastTime = performance.now();
    requestAnimationFrame(loop);
    // Restore controls visibility after restart (mobile only)
    const tc = document.getElementById('touch-controls');
    const ma = document.getElementById('mobile-actions');
    const showMobile = isMobileEnv();
    if (tc) tc.style.display = showMobile ? 'flex' : 'none';
    if (ma) ma.style.display = showMobile ? 'flex' : 'none';
  }
  
  function startGame() {
    const startCenter = document.getElementById('startCenter');
    if (startCenter) startCenter.style.display = 'none';
    overlay.classList.remove('show');
    gameOver = false;
    running = true;
    
    if (backgroundMusic) {
      backgroundMusic.volume = 0.5;
      backgroundMusic.play().catch(err => console.log('Autoplay bloqué'));
    }
    
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }
  
  const startPlayBtn = document.getElementById('startPlayBtn');
  if (startPlayBtn) startPlayBtn.addEventListener('click', startGame);
  
  const playBtn = document.getElementById('playBtn');
  if (playBtn) playBtn.addEventListener('click', startGame);

  // Bouton "Rejouer" dans l'overlay Game Over
  const overlayRestartBtn = document.getElementById('overlayRestartBtn');
  if (overlayRestartBtn) {
    overlayRestartBtn.addEventListener('click', () => {
      restart();
    });
  }
  
  const pauseBtn = document.getElementById('pauseBtn');
  if (pauseBtn) pauseBtn.addEventListener('click', () => {
    if (gameOver) return; // Ne pas permettre pause si game over
    running = !running;
    pauseBtn.textContent = running ? 'Pause' : 'Reprendre';
    if (backgroundMusic) {
      if (running) backgroundMusic.play().catch(() => {});
      else backgroundMusic.pause();
    }
    if (running) requestAnimationFrame(loop);
  });
  
  const superJumpBtn = document.getElementById('superJumpBtn');
  if (superJumpBtn) superJumpBtn.addEventListener('click', () => {
    nextJumpSuper = true;
    const superStatus = document.getElementById('superStatus');
    if (superStatus) superStatus.textContent = 'armé';
  });
  
  // Réglages de saut - Portée
  const jumpScaleInput = document.getElementById('jumpScale');
  const jumpValueSpan = document.getElementById('jumpValue');
  
  function updateJumpScale(value) {
    jumpRangeScale = Math.max(0.6, Math.min(1.8, value));
    if (jumpScaleInput) jumpScaleInput.value = jumpRangeScale;
    if (jumpValueSpan) jumpValueSpan.textContent = jumpRangeScale.toFixed(2) + '×';
  }
  
  if (jumpScaleInput) {
    jumpScaleInput.addEventListener('input', () => {
      updateJumpScale(parseFloat(jumpScaleInput.value));
    });
  }
  
  const jumpScalePlus = document.getElementById('jumpScalePlus');
  if (jumpScalePlus) {
    jumpScalePlus.addEventListener('click', () => {
      updateJumpScale(jumpRangeScale + JUMP_SCALE_STEP);
    });
  }
  
  const jumpScaleMinus = document.getElementById('jumpScaleMinus');
  if (jumpScaleMinus) {
    jumpScaleMinus.addEventListener('click', () => {
      updateJumpScale(jumpRangeScale - JUMP_SCALE_STEP);
    });
  }
  
  const jumpHeightInput = document.getElementById('jumpHeight');
  const jumpHeightValueSpan = document.getElementById('jumpHeightValue');
  
  function updateJumpHeight(value) {
    jumpHeightScale = Math.max(0.6, Math.min(4.0, value));
    if (jumpHeightInput) jumpHeightInput.value = jumpHeightScale;
    if (jumpHeightValueSpan) jumpHeightValueSpan.textContent = jumpHeightScale.toFixed(2) + '×';
  }
  
  if (jumpHeightInput) {
    jumpHeightInput.addEventListener('input', () => {
      updateJumpHeight(parseFloat(jumpHeightInput.value));
    });
  }
  
  const jumpHeightPlus = document.getElementById('jumpHeightPlus');
  if (jumpHeightPlus) {
    jumpHeightPlus.addEventListener('click', () => {
      updateJumpHeight(jumpHeightScale + JUMP_SCALE_STEP);
    });
  }
  
  const jumpHeightMinus = document.getElementById('jumpHeightMinus');
  if (jumpHeightMinus) {
    jumpHeightMinus.addEventListener('click', () => {
      updateJumpHeight(jumpHeightScale - JUMP_SCALE_STEP);
    });
  }
  
  // Raccourcis clavier pour ajuster hauteur et portée
  document.addEventListener('keydown', (e) => {
    // Hauteur: touches + et -
    if (e.code === 'Equal' || e.code === 'NumpadAdd') {
      e.preventDefault();
      updateJumpHeight(jumpHeightScale + JUMP_SCALE_STEP);
    }
    if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
      e.preventDefault();
      updateJumpHeight(jumpHeightScale - JUMP_SCALE_STEP);
    }
    // Portée: touches [ et ]
    if (e.code === 'BracketLeft') {
      e.preventDefault();
      updateJumpScale(jumpRangeScale - JUMP_SCALE_STEP);
    }
    if (e.code === 'BracketRight') {
      e.preventDefault();
      updateJumpScale(jumpRangeScale + JUMP_SCALE_STEP);
    }
  });
  
  // Contrôles tactiles pour mobile
  const touchLeft = document.getElementById('touch-left');
  const touchRight = document.getElementById('touch-right');
  const touchJump = document.getElementById('touch-jump');
  
  if (touchLeft) {
    touchLeft.addEventListener('touchstart', (e) => {
      e.preventDefault();
      input.left = true;
    });
    touchLeft.addEventListener('touchend', (e) => {
      e.preventDefault();
      input.left = false;
    });
  }
  
  if (touchRight) {
    touchRight.addEventListener('touchstart', (e) => {
      e.preventDefault();
      input.right = true;
    });
    touchRight.addEventListener('touchend', (e) => {
      e.preventDefault();
      input.right = false;
    });
  }
  
  if (touchJump) {
    const startGameIfNeeded = () => {
      if (!running && !gameOver) {
        running = true;
        const startCenter = document.getElementById('startCenter');
        if (startCenter) startCenter.style.display = 'none';
        requestAnimationFrame(loop);
      }
    };
    // Touch events (non-passive) + visual feedback
    touchJump.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      touchJump.classList.add('pressed');
      startGameIfNeeded();
      input.jump = true;
    }, { passive: false });
    touchJump.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      touchJump.classList.remove('pressed');
      input.jump = false;
    }, { passive: false });
    // Click fallback (short pulse like keyboard)
    touchJump.addEventListener('click', (e) => {
      e.preventDefault();
      startGameIfNeeded();
      touchJump.classList.add('pressed');
      input.jump = true;
      setTimeout(() => { input.jump = false; touchJump.classList.remove('pressed'); }, 80);
    });
    touchJump.addEventListener('mousedown', () => touchJump.classList.add('pressed'));
    touchJump.addEventListener('mouseup', () => touchJump.classList.remove('pressed'));
    touchJump.addEventListener('input', (e) => {
      if (e.inputType === 'touch') {
        e.preventDefault();
        e.stopPropagation();
      }
    }, { passive: false });
  }
  // Bouton tactile Super Saut: arme le prochain saut (équivalent touche 'S')
  const touchSuperJump = document.getElementById('touch-super-jump');
  if (touchSuperJump) {
    const armSuper = () => {
      nextJumpSuper = true;
      const superStatus = document.getElementById('superStatus');
      if (superStatus) superStatus.textContent = 'armé';
    };
    touchSuperJump.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      touchSuperJump.classList.add('pressed');
      armSuper();
    }, { passive: false });
    touchSuperJump.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      touchSuperJump.classList.remove('pressed');
    }, { passive: false });
    touchSuperJump.addEventListener('click', (e) => {
      e.preventDefault();
      touchSuperJump.classList.add('pressed');
      armSuper();
      setTimeout(() => touchSuperJump.classList.remove('pressed'), 100);
    });
    touchSuperJump.addEventListener('mousedown', () => touchSuperJump.classList.add('pressed'));
    touchSuperJump.addEventListener('mouseup', () => touchSuperJump.classList.remove('pressed'));
  }
  // Organiser les contrôles mobiles dans la barre inférieure (#touch-bar)
  const touchBar = document.getElementById('touch-bar');
  const touchControlsEl = document.getElementById('touch-controls');
  function arrangeMobileBar() {
    if (!touchBar) return;
    const isMobile = isMobileEnv();
    if (isMobile) {
      // Left group: arrows
      if (touchControlsEl && touchControlsEl.parentElement !== touchBar) touchBar.appendChild(touchControlsEl);
      // Right group: Super + Jump on the same line
      let rightGroup = document.getElementById('touch-right-group');
      if (!rightGroup) {
        rightGroup = document.createElement('div');
        rightGroup.id = 'touch-right-group';
        touchBar.appendChild(rightGroup);
      } else if (rightGroup.parentElement !== touchBar) {
        touchBar.appendChild(rightGroup);
      }
      const superBtn = document.getElementById('touch-super-jump');
      if (superBtn && superBtn.parentElement !== rightGroup) rightGroup.appendChild(superBtn);
      const jumpBtn = document.getElementById('touch-jump');
      if (jumpBtn && jumpBtn.parentElement !== rightGroup) rightGroup.appendChild(jumpBtn);
      touchBar.style.display = 'flex';
    } else {
      touchBar.style.display = 'none';
    }
  }
  arrangeMobileBar();
  const mobileSettingsBtn = document.getElementById('mobile-settings-btn');
  const mobileSettings = document.getElementById('mobile-settings');
  const closeSettings = document.getElementById('close-settings');
  const mobileControlsContainer = document.getElementById('mobile-controls-container');
  
  // Afficher le bouton réglages sur mobile
  if (window.innerWidth <= 768) {
    if (mobileSettingsBtn) mobileSettingsBtn.style.display = 'block';
  }
  if (mobileControlsContainer) {
    const controls = document.getElementById('controls');
    if (controls) {
      mobileControlsContainer.innerHTML = controls.innerHTML;
      // Réattacher les événements aux nouveaux éléments
      const mobileJumpScale = mobileControlsContainer.querySelector('#jumpScale');
      const mobileJumpHeight = mobileControlsContainer.querySelector('#jumpHeight');
      if (mobileJumpScale) {
        mobileJumpScale.addEventListener('input', () => {
          updateJumpScale(parseFloat(mobileJumpScale.value));
          if (jumpScaleInput) jumpScaleInput.value = mobileJumpScale.value;
        });
      }
      if (mobileJumpHeight) {
        mobileJumpHeight.addEventListener('input', () => {
          updateJumpHeight(parseFloat(mobileJumpHeight.value));
          if (jumpHeightInput) jumpHeightInput.value = mobileJumpHeight.value;
        });
      }
    }
  }
  
  if (mobileSettingsBtn) {
    mobileSettingsBtn.addEventListener('click', () => {
      if (mobileSettings) mobileSettings.style.display = 'block';
      // Hide on-screen controls while settings are open
      const tc = document.getElementById('touch-controls');
      const ma = document.getElementById('mobile-actions');
      if (tc) tc.style.display = 'none';
      if (ma) ma.style.display = 'none';
    });
  }
  
  if (closeSettings) {
    closeSettings.addEventListener('click', () => {
      if (mobileSettings) mobileSettings.style.display = 'none';
      // Restore on-screen controls on mobile
      if (window.innerWidth <= 768) {
        const tc = document.getElementById('touch-controls');
        const ma = document.getElementById('mobile-actions');
        if (tc) tc.style.display = 'flex';
        if (ma) ma.style.display = 'flex';
      }
    });
  }

  // Mobile pause and restart buttons
  const mobilePauseBtn = document.getElementById('mobile-pause');
  const mobileRestartBtn = document.getElementById('mobile-restart');
  if (mobilePauseBtn) {
    mobilePauseBtn.addEventListener('click', () => {
      if (gameOver) return;
      running = !running;
      mobilePauseBtn.textContent = running ? '⏸️' : '▶️';
      if (running) {
        requestAnimationFrame(loop);
      } else {
        if (backgroundMusic) backgroundMusic.pause();
      }
    });
  }
  if (mobileRestartBtn) {
    mobileRestartBtn.addEventListener('click', () => {
      restart();
      running = true;
      const overlayEl = document.getElementById('overlay');
      if (overlayEl) overlayEl.classList.remove('show');
      const startCenter = document.getElementById('startCenter');
      if (startCenter) startCenter.style.display = 'none';
      requestAnimationFrame(loop);
    });
  }
  
  // Objets du ciel (avions et nuages)
  function spawnSkyObject() {
    const el = document.createElement('div');
    el.className = 'sky-object';
    
    // Plus d'avions pendant le crépuscule (ciel rose)
    const progress = dayNightProgress;
    let planeChance = 0.35; // Chance de base
    if (progress >= 0.33 && progress <= 0.67) {
      // Pendant le crépuscule, augmenter la chance d'avions
      planeChance = 0.65; // Presque 2x plus d'avions
    }
    
    const isPlane = Math.random() < planeChance;
    const directionRight = Math.random() < 0.5;
    
    if (isPlane) {
      const img = directionRight ? 'assets/img/aviongd.png' : 'assets/img/aviondg.png';
      el.style.backgroundImage = `url(${img})`;
    } else {
      el.style.backgroundImage = 'url(assets/img/cloud.svg)';
    }
    
    // Raise altitude, especially in landscape
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    const top = (isLandscape ? 4 : 8) + Math.random() * (getGameHeight() * (isLandscape ? 0.18 : 0.24));
    el.style.top = top + 'px';
    
    const w = isPlane ? Math.min(96, getGameWidth() * 0.16) : Math.min(72, getGameWidth() * 0.12);
    const h = isPlane ? Math.min(36, getGameWidth() * 0.06) : Math.min(32, getGameWidth() * 0.053);
    el.style.width = w + 'px';
    el.style.height = h + 'px';
    
    const startX = directionRight ? -w - 20 : getGameWidth() + 20;
    el.style.left = startX + 'px';
    game.appendChild(el);
    
    const speed = isPlane ? (90 + Math.random() * 70) : (40 + Math.random() * 30);
    const dir = directionRight ? 1 : -1;
    
    let alive = true;
    let lastT = performance.now();
    function skyLoop(t) {
      if (!alive) return;
      const dt = (t - lastT) / 1000;
      lastT = t;
      
      const x = parseFloat(el.style.left);
      const nx = x + dir * speed * dt;
      el.style.left = nx + 'px';
      
      if (directionRight ? nx > getGameWidth() + 100 : nx < -w - 100) {
        alive = false;
        el.remove();
        return;
      }
      requestAnimationFrame(skyLoop);
    }
    requestAnimationFrame(skyLoop);
    
    // Délai réduit pendant le crépuscule pour plus d'avions
    let minDelay = SKY_MIN_DELAY;
    let meanExtra = SKY_MEAN_EXTRA;
    
    if (progress >= 0.33 && progress <= 0.67) {
      // Pendant le crépuscule, réduire les délais
      minDelay = 1.5; // Plus rapide
      meanExtra = 2; // Moins de variation
    }
    
    const u = Math.random();
    const delay = minDelay + (-Math.log(1 - u) * meanExtra);
    setTimeout(spawnSkyObject, delay * 1000);
  }
  
  setTimeout(spawnSkyObject, 1500 + Math.random() * 1200);
})();
  </script>
</body>
</html>
